Més tipus: estructures, slices i maps.
Aprèn com definir tipus basats en altres que ja existeixen: aquesta lliçò explica structs, arrays, slices i maps.

The Go Authors
https://golang.org

* Punters

Go té punters (o apuntadors).
Un punter conté l'adreça de memòria d'un valor.

El tipus `*T` és un punter a un valor `T`. El seu valor zero és `nil`.

	var p *int

L'operador `&` genera un punter al seu operand.

	i := 42
	p = &i

L'operador `*` denota el valor contingut del punter.

	fmt.Println(*p) // llegeix i a través del punter p
	*p = 21         // estableix i a través del punter p

Això es coneix com a "dereferenciació" o "indirecció".

A diferència de C, Go no permet l'aritmètica de punters.

.play moretypes/pointers.go

* Estructures

Una `struct` és una estructura d'un conjunt de camps de dades.

.play moretypes/structs.go

* Camps d'una estructura

Els camps d'una `struct` s'accedeixen mitjançant un punt.

.play moretypes/struct-fields.go

* Punters a estructures

Es pot accedir als camps d'una `struct` mitjançant un punter.

Per accedir al camp `X` d'una estructura tenint el punter a l'estructura `p`
podríem escriure `(*p).X`.
De tota manera aquesta notació és feixuga de manera que el llenguatge ens permet
escriure simplement `p.X`, sense cap indirecció explícita.

.play moretypes/struct-pointers.go

* Literals d'estructures

Un literal d'estructura denota una nova instància d'una estructura creada llistant els valors dels seus camps.

Pots llistar només els valors d'un subconjunt de camps utilitzant la sintaxis `Nom:` (l'ordre dels camps és irrellevant).

El prefix especial `&` crea un punter a l'espai reservat per la nova estructura.

_(NdT:_ _Un_literal_és_un_valor_fixat_al_codi_font_d'un_programa)_

.play moretypes/struct-literals.go

* Arrays

El tipus `[n]T` és un array de `n` valors del tipus `T`.

L'expressió

	var a [10]int

declara una variable `a` com un array de deu enters.

La longitud d'un array és part del seu tipus, de manera que els arrays no es poden redimensionar.
Això sembla limitant, però no us preocupeu;
Go proporciona una manera convenient de treballar amb arrays.

.play moretypes/array.go


* Slices (llesques)

Un array té una mida fixa.
Una slice (llesques), en canvi, és una vista dinàmicament dimensionada i flexible dels elements d'un array.
En la pràctica, els talls són molt més comuns que els arrays.

El tipus `[]T` és una slice amb elements del tipus `T`.

Un tall es forma especificant dos índexs, una límit inferior i una límit superior, separats per dos punts:

	a[low : high]

Això selecciona un rang semi-obert que inclou el primer element, però n'exclou l'últim.

L'expressió següent crea una slice que inclou els
elements 1 a 3 d' `a`:

	a[1:4]

.play moretypes/slices.go


* Les slices són com referències a arrays

Les llesques no emmagatzemen dades,
només descriuen una secció d'un array subjacent.

El canvi dels elements d'una slice modifica els
elements corresponents del seu array subjacent.

Altres slices que comparteixen el mateix array
subjacent veuran aquests canvis.

.play moretypes/slices-pointers.go


* Literals de Slice

Els literals de slices són com els literals d'arrays, però sense la longitud.

Per especificar una capacitat, passi un tercer argument a make.

Això és un literal d'array:

	[3]bool{true, true, false}

I això crea el mateix array que abans,
i després construeix una "slice" que el referència:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Valors per defecte en Slices

Quan es talla una "slice", es poden ometre els límits alt o baix per utilitzar els seus valors per defecte

El valor per defecte és zero per al límit inferior i la longitud de la "slice" per al límit superior.

Per a l'array

	var a [10]int

aquestes slices són equivalents:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Longitud i capacitat d'una Slice

Una slice té tant una _longitud_ com una _capacitat_.

La longitud és el nombre d'elements que conté.

La capacitat és el nombre d'elements de l'array subjacent,
comptant des del primer element de la "slice".


La longitud i la capacitat d'una slice `s` s'obtenen utilitzant les expressions
`len(s)` and `cap(s)`.

Pots augmentar la longitud d'una slice (llesca) tornant-la a tallar,
sempre que tingui capacitat suficient.
Prova de canviar una de les operacions de tall de l'exemple del programa
per allargar-lo més enllà de la seva capacitat i mira què passa.

.play moretypes/slice-len-cap.go


* Slices nil (llesques nul·les)

El valor zero d'una llesca és `nil`.

Una llesca nul·la té una longitud i capacitat de 0
i no té cap array subjacent.

.play moretypes/nil-slices.go


* Creating a slice with make

Slices can be created with the built-in `make` function;
this is how you create dynamically-sized arrays.

The `make` function allocates a zeroed array
and returns a slice that refers to that array:

	a := make([]int, 5)  // len(a)=5

To specify a capacity, pass a third argument to `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Slices of slices

Slices can contain any type, including other slices.

.play moretypes/slices-of-slice.go


* Appending to a slice

It is common to append new elements to a slice, and so Go provides a built-in
`append` function. The [[https://golang.org/pkg/builtin/#append][documentation]]
of the built-in package describes `append`.

	func append(s []T, vs ...T) []T

The first parameter `s` of `append` is a slice of type `T`, and the rest are
`T` values to append to the slice.

The resulting value of `append` is a slice containing all the elements of the
original slice plus the provided values.

If the backing array of `s` is too small to fit all the given values a bigger
array will be allocated. The returned slice will point to the newly allocated
array.

(To learn more about slices, read the [[https://blog.golang.org/go-slices-usage-and-internals][Slices: usage and internals]] article.)

.play moretypes/append.go


* Range

The `range` form of the `for` loop iterates over a slice or map.

When ranging over a slice, two values are returned for each iteration.
The first is the index, and the second is a copy of the element at that index.

.play moretypes/range.go

* Range continued

You can skip the index or value by assigning to `_`.

    for i, _ := range pow
    for _, value := range pow

If you only want the index, you can omit the second variable.

    for i := range pow

.play moretypes/range-continued.go

* Exercise: Slices

Implement `Pic`. It should return a slice of length `dy`, each element of which is a slice of `dx` 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include `(x+y)/2`, `x*y`, and `x^y`.

(You need to use a loop to allocate each `[]uint8` inside the `[][]uint8`.)

(Use `uint8(intValue)` to convert between types.)

.play moretypes/exercise-slices.go

* Maps

A map maps keys to values.

The zero value of a map is `nil`.
A `nil` map has no keys, nor can keys be added.

The `make` function returns a map of the given type,
initialized and ready for use.

.play moretypes/maps.go

* Map literals

Map literals are like struct literals, but the keys are required.

.play moretypes/map-literals.go

* Map literals continued

If the top-level type is just a type name, you can omit it from the elements of the literal.

.play moretypes/map-literals-continued.go

* Mutating Maps

Insert or update an element in map `m`:

	m[key] = elem

Retrieve an element:

	elem = m[key]

Delete an element:

	delete(m, key)

Test that a key is present with a two-value assignment:

	elem, ok = m[key]

If `key` is in `m`, `ok` is `true`. If not, `ok` is `false`.

If `key` is not in the map, then `elem` is the zero value for the map's element type.

*Note:* If `elem` or `ok` have not yet been declared you could use a short declaration form:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Exercise: Maps

Implement `WordCount`.  It should return a map of the counts of each “word” in the string `s`. The `wc.Test` function runs a test suite against the provided function and prints success or failure.

You might find [[https://golang.org/pkg/strings/#Fields][strings.Fields]] helpful.

.play moretypes/exercise-maps.go

* Function values

Functions are values too. They can be passed around just like other values.

Function values may be used as function arguments and return values.

.play moretypes/function-values.go

* Function closures

Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the `adder` function returns a closure. Each closure is bound to its own `sum` variable.

.play moretypes/function-closures.go

* Exercise: Fibonacci closure

Let's have some fun with functions.

Implement a `fibonacci` function that returns a function (a closure) that
returns successive [[https://en.wikipedia.org/wiki/Fibonacci_number][fibonacci numbers]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
